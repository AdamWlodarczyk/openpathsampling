(*
PlotTrajectory1D::usage = "PlotTrajectory1D[data] plots a 1D list of data including a histogram at the side";
TimeScaling::usage = "TimeScaling is an option for PlotTrajectory1D.";
StepSize::usage = "StepSize is an option for PlotTrajectory1D.";
*)

(*
PositionStatePlot[pStateList_,positionList_,pOptions:OptionsPattern[PositionStatePlot]] := 
        Module[{pointList, pFill={}, pGrid={}, pText={}, pOutline={}, pColoring={}},
            pointList=If[NumberQ[positionList],
                Table[{Mod[ii,positionList]+1,Floor[ii/positionList]+1},{ii,0,positionList^2-1}],
                positionList
            ];
            If[OptionValue[PositionStatePlot,optsKM,Outline],
                {vorvert,vorval}=VoronoiDiagram[data2D];
                pOutline=DiagramPlot[positionList];
            ];
            If[Grid/. replaceRules,
                pGrid={RGBColor[0,0,0],Thickness[0.012`],GridStyle/. replaceRules,(Line[{#1[[2]]+zustandsabstand {0,0},#1[[2]]+zustandsabstand {1,0},#1[[2]]+zustandsabstand {1,1},#1[[2]]+zustandsabstand {0,1},#1[[2]]+zustandsabstand {0,0}}]&)/@({#1,GetPositionFromState[#1]}&)/@pStateList}
            ];
            If[Text/. replaceRules,
                pText={RGBColor[1,1,1],Style[Function[(Text[ToString[#1[[1]]],#1[[2]]+{0.5`,0.5`} zustandsabstand])]/@({#1,GetPositionFromState[#1]}&)/@pStateList,BaseStyle/. replaceRules]};
            ];
            If[Fill/. replaceRules,
                pFill={RGBColor[0.88`,0.47`,0],FillStyle/. replaceRules,({Rectangle[#1[[2]]+zustandsabstand {0,0},#1[[2]]+zustandsabstand {1,1}]}&)/@({#1,GetPositionFromState[#1]}&)/@pStateList};
            ];
            If[Coloring/. replaceRules,
                pColoring={({(ColoringFunction/.replaceRules)[(ColoringData/.replaceRules)[[#1[[1]]]]],Rectangle[#1[[2]]+zustandsabstand {0,0},#1[[2]]+zustandsabstand {1,1}]}&)/@({#1,GetPositionFromState[#1]}&)/@pStateList};
            ];
            ret=Graphics[Flatten[{pFill,pColoring,pText,pGrid,pOutline}]];
            ret
        ];
*)

(*
PlotTrajectory1D[trace_?MatrixQ, opts___] := 
 Module[{stepSize, timeScaling, hist},
  stepSize = StepSize /. {opts} /. {StepSize -> 20};
  timeScaling = TimeScaling /. {opts} /. {TimeScaling -> 1};
  hist = SmoothKernelDistribution[
    Take[trace, {1, Length[trace], stepSize}]];
  backdensity = 
   DensityPlot[PDF[hist, y], {x, 0, 60}, {y, 12, 15.5}, 
    ColorFunction -> (GrayLevel[Min[1, Max[1 - #, 0]]] &), 
    PlotPoints -> 40];
  Show[ListPlot[
    Take[Transpose[{Range[0, Length[trace] - 1]*timeScaling, 
       trace[[1]]}], {1, Length[trace], stepSize}], 
    RemoveRules[{TimeScaling, StepSize}, opts], 
    PlotStyle -> Directive[Black, Thin], AspectRatio -> 0.10, 
    ImageSize -> 800, FrameStyle -> Thickness[0.0005]
    ]]
  ]
  
  *)
  
  (*
PotentialOfMeanForce::usage = "PotentialOfMeanForce[]";
PotentialOfMeanForceBins::usage = "";
PotentialOfMeanForceSensitivityMatrix::usage = "";
PotentialOfMeanForceError::usage = "";
CommittorReactionCoordinate = "";
SteadyStateCommittor::usage = "";
*)

(*
CommittorSensitivityMatrix::usage = "";
*)


(*
TransitionMatrix/:SteadyStateCommittor[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],states_] := 
        Module[ {cM,eq},
            cM = m;
            eq = Equilibrium[TransitionMatrix[m]];
            cM[[All,states[[2]]]] = Table[If[ ii==states[[1]],
                                              eq[[states[[2]]]] / eq[[states[[1]]]],
                                              0
                                          ],{ii,1,Length[cM]}];
            {cM,(#/Total[#])&[Eigenvectors[cM,Min[Length[states]+50,Length[m]]][[1]]]}
        ]
TransitionMatrix/:PotentialOfMeanForce[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],states_] := 
        Module[ {committor, equilibrium, s2,s3,dd},
            committor = Committor[TransitionMatrix[m,opts],states][[2]];
            equilibrium = Equilibrium[TransitionMatrix[m,opts]];
            s2 = Sort[Transpose[{committor,equilibrium}],#1[[1]]<#2[[1]]&];
            dd = 0;
            s3 = Transpose[{s2[[All,1]],Table[dd = dd+s2[[ii,2]],{ii,1,Length[s2]}]}];
            Transpose[{s3[[All,1]],Identity[s3[[All,2]]]}]
        ]

TransitionMatrix/:PotentialOfMeanForceBins[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],states_,bins_] := 
        Module[ {committor, equilibrium, s2},
            committor = Committor[TransitionMatrix[m,opts],states][[2]];
            equilibrium = Equilibrium[TransitionMatrix[m,opts]];
            s2 = Sort[Transpose[{committor,equilibrium}],#1[[1]]<#2[[1]]&];
            Select[Table[{(bins[[nn]]+bins[[nn+1]])/2,-Log[Apply[Plus,Select[s2,(#[[1]]>=bins[[nn]]&&#[[1]]<=bins[[nn+1]])&][[All,2]]]/(bins[[nn+1]]-bins[[nn]])]},{nn,1,Length[bins]-1}],#[[2]]<\[Infinity]&]
        ]

TransitionMatrix/:CommittorReactionCoordinate[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],states_,expectations_] := 
        Module[ {committor,s2,s3,dd},
            committor = Committor[TransitionMatrix[m,opts],states][[2]];
            s2 = Sort[Transpose[{committor,expectations}],#1[[1]]<#2[[1]]&];
            dd = 0;
            s3 = Transpose[{s2[[All,1]],Table[dd = dd+s2[[ii,2]],{ii,1,Length[s2]}]}];
            Transpose[{s3[[All,1]],s3[[All,2]]/Apply[Plus,expectations]}]
        ]
        
*)

(*
TransitionMatrix/:CommittorSensitivityMatrix[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],states_] := 
        Module[ {cM,cS,cA,size},
            size = Length[m];
            cS = IdentityMatrix[size][[Complement[Range[size],states]]];
            cM = Inverse[(m-IdentityMatrix[size])[[Complement[Range[size],states],Complement[Range[size],states]]]];
            cA = Transpose[cS].cM.cS;
            Transpose[cA]
        ]
        *)
        
        (*
TransitionMatrix/:PotentialOfMeanForceError[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],state1_,state2_] := 
        Module[ {cM,cP,size,cC,cL,cB},
            size = Length[m];
            cM = PseudoInverse[Join[Transpose[m]-IdentityMatrix[size],{Table[1,{size}]}]];
            cP = #/Apply[Plus,#]&[Eigenvectors[Transpose[m],1][[1]]];
            cC = Committor[TransitionMatrix[m,opts],{state1,state2}][[2]];
            cL = Sort[Transpose[{Range[Length[m]],cC}],#1[[2]]<#2[[2]]&];
            Table[
                cB = Map[Apply[Plus,#]&,cM[[All,cL[[Range[nn],1]]]]];
                {cL[[nn,2]],Apply[Plus,Abs[Flatten[Outer[Plus,cB,-cB]]]]}
            ,{nn,1,10}]
        ]

TransitionMatrix/:PotentialOfMeanForceSensitivityMatrix[TransitionMatrix[m_?MatrixQ,opts:OptionsPattern[TransitionMatrix]],state1_,state2_,c_] := 
        Module[ {cM,cP,size,cC,cL,cB},
            size = Length[m];
            cM = PseudoInverse[Join[Transpose[m]-IdentityMatrix[size],{Table[1,{size}]}]];
            cP = #/Apply[Plus,#]&[Eigenvectors[Transpose[m],1][[1]]];
            cC = Committor[TransitionMatrix[m,opts],{state1,state2}][[2]];
            cL = Select[Transpose[{Range[Length[m]],cC}],(#[[2]]<=c)&][[All,1]];
            cB = Map[Apply[Plus,#]&,cM[[All,cL]]];
            Outer[Plus,cB,-cB]
        (*Table[cP[[aa]]*(cB[[aa]]-cB[[bb]]),{aa,1,size},{bb,1,size}]*)
        ]
        *)
        
        GetCrossCorrelation::usage = "GetCrossCorrelation[correlationmodel, obs1, obs2, lagtime] returns the crosscorrelation value for the CorrelationModel and observables obs1 and obs2 given as vectors at lagtime.";

        Options[PositionStatePlot]           = {Text->False, TextStyle->{RGBColor[1,1,1]}, Grid->True, GridStyle->{RGBColor[0,0,0],Thickness[0.012`]}, Outline->False, OutlineStyle->{}, Fill->True, FillStyle->{RGBColor[0.88`,0.47`,0]}, Coloring->False};
